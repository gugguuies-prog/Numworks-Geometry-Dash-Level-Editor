# A recreation of Geometry Dash for Numworks calculators.
# Credits: Calm_Repeat_7267 and wperez274

from time import sleep
from random import randint
from kandinsky import fill_rect as FILL, draw_string as STR
from ion import KEY_OK, KEY_EXE, KEY_UP, keydown as KEY


START_MENU_COLOR = (0, 0, 0)

FILL(0, 0, 322, 222, START_MENU_COLOR)
STR("Geometry Dash", 90, 60, "white", START_MENU_COLOR)
STR("Key [Up]/[OK] = Jump", 60, 100, "white", START_MENU_COLOR)
STR("Click [EXE] to play", 65, 140, "white", START_MENU_COLOR)

sleep(0.5)

while not KEY(KEY_EXE):  # Waiting for a key to be pressed
    pass

game = True
TICK = 1/30  # 30 FPS

levels: list[tuple[
    list[list[int]],    # blocks[x_tile, y_tile, width_tiles, height_tiles]
    list[list[int]],    # spikes[x_tile, y_tile, orientation]
    int,                # level end (mesured in tiles)
    tuple[int,int,int], # bg color (red, green, blue)
    tuple[int,int,int]  # ground color (red, green, blue)
]] = [
    (
        [[17, 6, 13, 1], [30, 6, 4, 1], [0, 6, 6, 1], [6, 6, 11, 1], [34, 6, 26, 1]],
        [[28, 6, 0], [30, 6, 0]],
        60, (30, 30, 30), (100, 100, 255)
    )
]

game_started = False

current_level = 0

player_x = 50
player_y = 172

map_offset_x = 0

can_jump = True

is_jumping = False
is_falling = False

jump_velocity = 32
air_ticks = 0

PLAYER_WIDTH = 20
PLAYER_HEIGHT = 20

RESPAWN_TIME = 1

attempts = 0

bg_color = (0, 0, 0)
player_color = (0, 0, 0)
ground_color = (0, 0, 0)
RANDOMIZE_COLORS = False
DARK_GREEN = (0, 150, 0)
DARK_BLUE = (0, 0, 150)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)

SCREEN_WIDTH = 320
TILE_SIZE_X = 10


def get_visible_tile_range():
    first_tile = (-map_offset_x) // TILE_SIZE_X - 2
    last_tile = first_tile + (SCREEN_WIDTH // TILE_SIZE_X) + 4
    return first_tile, last_tile

def draw_player(color: tuple[int, int, int] | None = None):
    global PLAYER_WIDTH, PLAYER_HEIGHT, player_color
    if color:
        FILL(player_x, player_y, PLAYER_WIDTH, PLAYER_HEIGHT, color)
    else:
        FILL(player_x, player_y, PLAYER_WIDTH, PLAYER_HEIGHT, player_color)

def draw_spike(x_tile: int, y_tile: int, orientation: int):
    for i in range(5):
        FILL(
            map_offset_x + x_tile * 10 - 10 + i * 2,
            y_tile * 32 - i * 4 + (2 * i * 4 * orientation) - 4 * (1 - orientation), 20 - i * 4, 4, ground_color
        )
        FILL(
            map_offset_x + x_tile * 10 + 10 - i * 2,
            y_tile * 32 - i * 4 + (2 * i * 4 * orientation) - 4 * (1 - orientation), 6, 4, bg_color
        )

def draw_platform(x_tile: int, y_tile: int, width_tiles: int, height_tiles: int):
    FILL(
        map_offset_x + x_tile * 10, y_tile * 32,
        10 * width_tiles, height_tiles * 32, ground_color
    )

    if width_tiles < 0:
        FILL(map_offset_x + x_tile * 10, y_tile * 32, 6, height_tiles * 32, bg_color)
    else:
        FILL(map_offset_x + x_tile * 10 + width_tiles * 10, y_tile * 32, 6, height_tiles*32, bg_color)

def height_tiles(tile_x: int):
    FILL(map_offset_x + tile_x * 10, 0, 10, 222, (0, 255, 0))
    FILL(map_offset_x + tile_x * 10 + 10, 0, 6, 222, bg_color)

def draw_level():
    first_tile, last_tile = get_visible_tile_range()

    # Spikes
    for x, y, orientation in levels[current_level][1]:
        if first_tile <= x <= last_tile:
            draw_spike(x, y, orientation)

    # Platforms
    for x, y, w, h in levels[current_level][0]:
        if x + w >= first_tile and x <= last_tile:
            draw_platform(x, y, w, h)

    # Endwall
    end_x = levels[current_level][2]
    if first_tile <= end_x <= last_tile:
        FILL(map_offset_x + end_x * 10, 0, 10, 222, (0, 255, 0))
        FILL(map_offset_x + end_x * 10 + 10, 0, 6, 222, bg_color)


def respawn():
    global attempts, map_offset_x, player_y, bg_color
    attempts += 1

    set_colors()
    FILL(0, 0, 320, 222, bg_color)
    map_offset_x = 0
    player_y = 172
    draw_level()
    draw_player()

def set_colors():
    global bg_color, player_color, ground_color, current_level, levels

    if RANDOMIZE_COLORS:
        player_color = (randint(0, 155), randint(0, 155), randint(0, 155))
        bg_color = (randint(210, 255), randint(210, 255), randint(210, 255))
        ground_color = (randint(0, 55), randint(0, 55), randint(0, 55))

    else:
        player_color = (255, 255, 0)
        bg_color = levels[current_level][3]
        ground_color = levels[current_level][4]

def get_player_tile_x():
    return (-map_offset_x + player_x) // 10

def check_collision():
    px = player_x
    py = player_y
    pw = PLAYER_WIDTH
    ph = PLAYER_HEIGHT

    player_tile = get_player_tile_x()
    first_tile = player_tile - 2
    last_tile = player_tile + 2

    # Platforms
    for x, y, w, h in levels[current_level][0]:
        if x > last_tile or x + w < first_tile:
            continue

        rx = x * 10 + map_offset_x
        ry = y * 32
        rw = w * 10
        rh = h * 32

        if (
            px + pw > rx and px < rx + rw and
            py + ph > ry and py < ry + rh
        ):
            return True

    # Spikes
    for x, y, orientation in levels[current_level][1]:
        if x < first_tile or x > last_tile:
            continue

        rx = x * 10 + map_offset_x
        ry = y * 32

        if orientation == 0:  # regular spike
            hit_y1 = ry - 16
            hit_y2 = ry
        else:  # upside down spike
            hit_y1 = ry
            hit_y2 = ry + 16

        if (
            px + pw > rx and px < rx + 16 and
            py + ph > hit_y1 and py < hit_y2
        ):
            return True

    return False


respawn()


while game:  # Game loop
    # Physics

    if not is_jumping:
        for i in range(len(levels[current_level][0])):
            if (
                player_y + 20 == levels[current_level][0][i][1] * 32 and levels[current_level][0][i][0] * 10 + map_offset_x -19 <= 50 <= levels[current_level][0][i][2] * 10 + levels[current_level][0][i][0] * 10 + map_offset_x
            ):
                can_jump = True
                is_falling=False
                break
            else:
                can_jump = False
                is_falling = True

        if is_falling == True:
            draw_player(bg_color)
            player_y += 16

        if (
            KEY(KEY_OK) and can_jump == True
            or KEY(KEY_UP) and can_jump == True
        ):
            draw_player(bg_color)
            is_jumping = True
            player_y -= int(jump_velocity)
            jump_velocity = jump_velocity / 2

    elif can_jump:
        draw_player(bg_color)

        for k in range(len(levels[current_level][0])):
            if player_y + 20 != levels[current_level][0][k][1] * 32:
                is_jumping = True
            elif (
                levels[current_level][0][k][0] * 10 + map_offset_x-19 < 50 < levels[current_level][0][k][0] * 10 + map_offset_x + levels[current_level][0][k][2] * 10 + 20
            ):
                is_jumping = False
                break

        if is_jumping:
            player_y -= int(jump_velocity)
            if jump_velocity > 2:
                jump_velocity = jump_velocity / 2
            elif jump_velocity == 2:
                jump_velocity = 0
            elif jump_velocity == 0:
                air_ticks += 1

                if air_ticks == 4:
                    air_ticks = 0
                    jump_velocity = -2
            elif jump_velocity <= (-2) and jump_velocity > (-32):
                jump_velocity=jump_velocity*2
            else:
                is_jumping  = False
                jump_velocity = 32
                can_jump = True
        else:
            is_jumping  = False
            jump_velocity = 32
            can_jump = True


    # Labels

    attempts_label = str(attempts)

    if attempts < 100:
        attempts_label = "0" + attempts_label
        if attempts < 10:
            attempts_label = "0" + attempts_label

    STR(" Level:" + str(current_level + 1) + " ", 0, 0, bg_color, BLACK)
    STR(" Attempts:" + attempts_label + " ", 180, 0, "red", BLACK)


    # Drawing

    draw_player(player_color)

    map_offset_x -= 6
    draw_level()

    if player_y + PLAYER_HEIGHT > 222 or check_collision():  # player dies
        draw_level()
        draw_player(RED)

        sleep(RESPAWN_TIME)
        respawn()


    sleep(TICK)  # tick


    # Endscreen

    if player_x + PLAYER_WIDTH > levels[current_level][2] * 10 + map_offset_x:
        FILL(0, 0, 322, 222, BLACK)
        STR("LEVEL COMPLETED", 85, 60, GREEN, BLACK)
        STR("Click [EXE] to go", 75, 100, WHITE, BLACK)
        STR("to the level " + str(current_level + 2), 90, 140, WHITE, BLACK)

        current_level += 1  # Next level
        if len(levels) == current_level:  # No more levels
            break

        while not KEY(KEY_EXE):  # Waiting for a key to be pressed
            pass

        respawn()

# Game endscreen

FILL(0, 0, 322, 222, DARK_GREEN)
STR("GAME COMPLETED!", 85, 60, WHITE, DARK_GREEN)
STR("Attempts:" + str(attempts), 110, 100, WHITE, DARK_GREEN)
STR("By Gild56 (Subscribe on YT)", 30, 140, WHITE, DARK_GREEN)
